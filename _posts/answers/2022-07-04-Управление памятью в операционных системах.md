---
layout: post
title: "Управление памятью в операционных системах"
categories: sppo-questions pors-questions
---

## Описание

В однозадачных системах основная память разделяется на две части: одна часть - для операционной системы (резидентный
монитор, ядро), а вторая - для выполняющейся в текущий момент времени программы. В многозадачных системах
"пользовательская" часть памяти должна быть распределена для размещения нескольких процессов. Эта задача распределения
выполняется операционной системой динамически и известна под названием **управление памятью** (memory management).

Эффективное управление памятью жизненно важно для многозадачных систем. Если в памяти располагается только небольшое
число процессов, то большую часть времен все эти процессы будут находиться в состоянии ожидания выполнения операций
ввода-вывода, и загрузка процессора будет низкой. Таким образом, желательно эффективное распределение памяти,
позволяющее разместить в ней как можно больше процессов.

Глава начинается с рассмотрения требований, которым должны удовлетворять разрабатываемые системы управления памятью.
Позже мы приступим к рассмотрению различных технологий управления памятью, начав с применения нескольких простых схем.

В табл. 7.1 приведены некоторые ключевые термины по данной теме.

ТАБЛИЦА 7.1. ОСНОВНЫЕ ТЕРМИНЫ, СВЯЗАННЫЕ С УПРАВЛЕНИЕМ ПАМЯТЬЮ

|                       |                                                                                                                                                                                                                                                                                                                                |
|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Кадр** (frame)      | Блок основной памяти фиксированной длины                                                                                                                                                                                                                                                                                       |
| **Страница** (page)   | Блок данных фиксированной длины, находящийся во вторичной памяти (такой, как диск). Страница данных может быть временно скопирована в кадр основной памяти                                                                                                                                                                     |
| **Сегмент** (segment) | Блок данных переменной длины, находящийся во вторичной памяти. В доступную область основной памяти может быть скопирован сегмент полностью (сегментация); возможно также разделение сегмента на страницы, которые копируются в основную память по отдельности (комбинированная сегментация, или страничная организация памяти) |

## ТРЕБОВАНИЯ К УПРАВЛЕНИЮ ПАМЯТЬЮ

При рассмотрении различных механизмов и стратегий, связанных с управлением памятью, полезно помнить требования, которым
они должны удовлетворять. Эти требования включают следующее.

- Перемещение
- Защита
- Совместное использование
- Логическая организация
- Физическая организация

### Перемещение

В многозадачной системе доступная основная память в общем случае разделяется среди множества процессов. Обычно
программист не знает заранее, какие программы будут резидентно находиться в основной памяти во время работы
разрабатываемой им программы. Кроме того, для максимизации загрузки процессора желательно иметь большой пул процессов,
готовых к выполнению, для чего требуется возможность загрузки и выгрузки активных процессов из основной памяти.
Требование, чтобы выгруженная из памяти программа была вновь загружена в то же самое место, где находилась и ранее, было
бы слишком сильным ограничением. Крайне желательно, чтобы программа могла быть **перемещена** (relocate) в другую
область памяти.

Таким образом, заранее неизвестно, где именно будет размещена программа, а кроме того, программа может быть перемещена
из одной области памяти в другую при свопинге. Эти обстоятельства обусловливают наличие определенных технических
требований к адресации, проиллюстрированных на рис. 7.1. На рисунке представлен образ процесса. Дпя простоты
предположим, что образ процесса занимает одну непрерывную область основной памяти. Очевидно, что операционной системе
необходимо знать местоположение управляющей информации процесса и стека выполнения, а также точки входа для начала
выполнения процесса. Поскольку управлением памятью занимается операционная система и она же размещает процесс в основной
памяти, соответствующие адреса она получает автоматически. Однако, помимо получения операционной системой указанной
информации, процесс должен иметь возможность обращаться к памяти в самой программе. Так, команды ветвления содержат
адреса, указывающие на команды, которые должны быть выполнены после них; команды обращения к данным - адреса байтов или
слов, с которыми они работают. Так или иначе, но процессор и программное обеспечение операционной системы должны быть
способны перевести ссылки в коде программы в реальные физические адреса, соответствующие текущему расположению программы
в основной памяти.

### Защита

Каждый процесс должен быть защищен от нежелательного воздействия других процессов, случайного или преднамеренного.
Следовательно, код других процессов не должен иметь возможности без разрешения обращаться к памяти данного процесса для
чтения или записи. Однако удовлетворение требованию перемещаемости усложняет задачу защиты.

![Требования к адресации процесса](/assets/q63-1.png)
Рис. 7.1. Требования к адресации процесса

Поскольку расположение программы в основной памяти непредсказуемо, проверка абсолютных адресов во время компиляции
невозможна. Кроме того, в большинстве языков программирования возможно динамическое вычисление адресов во время
выполнения (например, вычисление адреса элемента массива или указателя на поле структуры данных). Следовательно, во
время работы программы необходимо выполнять проверку всех обращений к памяти, генерируемых процессом, чтобы
удостовериться, что все они - только к памяти, выделенной данному процессу. К счастью, как вы увидите позже, механизмы
поддержки перемещений обеспечивают и поддержку защиты.

Обычно пользовательский процесс не может получить доступ ни к какой части операционной системы - ни к коду, ни к данным.
Код одного процесса не может выполнить команду ветвления, целевой код которой находится в другом процессе. Если не
приняты специальные меры, код одного процесса не может получить доступ к данным другого процесса. Процессор должен быть
способен прервать выполнение таких команд.

Заметим, что требования защиты памяти должны быть удовлетворены на уровне процессора (аппаратного обеспечения), а не на
уровне операционной системы (программного обеспечения), поскольку операционная система не в состоянии предвидеть все
обращения к памяти, которые будут выполнены программой. Даже если бы такое было возможно, сканирование каждой программы
в поиске предлагаемых нарушений защиты было бы слишком расточительным с точки зрения использования процессорного
времени. Следовательно, соответствующие возможности аппаратного обеспечения - единственное средство определения
допустимости обращения к памяти (данным или коду)во время работы программы.

### Совместное использование

Любой механизм защиты должен иметь достаточную гибкость для того, чтобы обеспечить возможность нескольким процессам
обращаться к одной и той же области основной памяти. Например, если несколько процессов выполняют один и тот же машинный
код, то будет выгодно позволить каждому процессу работать с одной и той же копией этого кода, а не создавать
собственную. Процессам, сотрудничающим в работе над некоторой задачей, может потребоваться совместный доступ к одним и
тем же структурам данных. Система управления памятью должна, таким образом, обеспечивать управляемый доступ к
разделяемым областям памяти, при этом никоим образом не ослабляя защиту памяти. Как мы увидим позже, механизмы поддержки
перемещений обеспечивают и поддержку совместного использования памяти.

### Логическая организация

Практически всегда основная память в компьютерной системе организована как линейное (одномерное) адресное пространство,
состоящее из последовательности байтов или слов. Аналогично организована и вторичная память на своем физическом уровне.
Хотя такая организация и отражает особенности используемого аппаратного обеспечения, она не соответствует способу,
которым обычно создаются программы. Большинство программ организованы в виде модулей, одни из которых неизменны (только
для чтения, только для выполнения), а другие содержат данные, которые могут быть изменены. Если операционная система и
аппаратное обеспечение компьютера могут эффективно работать с пользовательскими программами и данными, представленными
модулями, то это обеспечивает ряд преимуществ.

1. Модули могут быть созданы и скомпилированы независимо один от другого, при этом все ссылки из одного модуля во второй
   разрешаются системой во время работы программы
2. Разные модули могут получить разные степени защиты (только для чтения, только для выполнения) за счет весьма
   умеренных накладных расходов.
3. Возможно применение механизма, обеспечивающего совместное использование модулей разными процессами. Основное
   достоинство обеспечения совместного использования на уровне модулей заключается в том, что они соответствуют взгляду
   программиста на задачу и, следовательно, ему проще определить, требуется ли совместное использование того или иного
   модуля.

Инструментом, наилучшим образом удовлетворяющим данным требованиям, является сегментация, которая будет рассмотрена в
данной главе среди прочих методов управления памятью.

### Физическая организация

Как указывалось в разделе 1.5, память компьютера разделяется как минимум на два уровня: основная и вторичная. Основная
память обеспечивает быстрый доступ по относительно высокой цене; кроме того, она энергозависима, т.е. не обеспечивает
долговременное хранение. Вторичная память медленнее и дешевле основной и обычно энергонезависима. Следовательно,
вторичная память большой емкости может служить для долговременного хранения программ и данных, а основная память меньшей
емкости - для хранения программ и данных, использующихся в текущий момент.

В такой двухуровневой структуре основной заботой системы становится организация потоков информации между основной и
вторичной памятью. Ответственность за эти потоки может быть возложена и на отдельного программиста, но это непрактично и
нежелательно по следующим причинам.

1. Основной памяти может быть недостаточно для программы и ее данных. В этом случае программист вынужден прибегнуть к
   практике, известной как структуры с перекрытием - **оверлеи** (overlay), когда программа и данные организованы таким
   образом, что различные модули могут быть назначены одной и той же области памяти; основная программа при этом
   ответственна за перезагрузку модулей при необходимости. Даже при помощи соответствующего инструментария компиляции
   оверлеев разработка таких программ приводит к дополнительным затратам времени программиста.
2. Во многозадачной среде программист при разработке программы не знает, какой объем памяти будет доступен программе и
   где эта память будет располагаться.

Таким образом, очевидно, что задача перемещения информации между двумя уровнями памяти должна возлагаться на
операционную систему. Эта задача является сущностью управления памятью.
