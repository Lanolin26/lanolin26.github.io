---
layout: post
title: "Управление памятью в операционных системах"
categories: sppo-questions pors-questions
---

## Описание 1

Лучше всего потребности пользователя удовлетворяются вычислительной средой, поддерживающей модульное программирование и
гибкое использование данных. Нужно обеспечить эффективный и систематичный контроль над размещением данных в запоминающем
устройстве со стороны управляющих программ операционной системы. Исходя из сформулированных требований, операционная
система должна выполнять такие функции.

1. **Изоляция процессов**. Операционная система должна следить за тем, чтобы ни один из независимых процессов не смог
   изменить содержимое памяти, отведенное другому процессу, и наоборот.
2. **Автоматическое размещение и управление**. Программы должны динамически размещаться в памяти в соответствии с
   определенными требованиями. Распределение памяти должно быть прозрачным для программиста. Таким образом, программист
   будет избавлен от необходимости следить за ограничениями, связанными с конечностью памяти, а операционная система
   повышает эффективность работы вычислительной системы, выделяя заданиям только тот объем памяти, который нм необходим.
3. **Поддержка модульного программирования**. Программист должен иметь возможность определять модули программы, а также
   динамически их создавать, уничтожать и изменять их размер.
4. **Защита и контроль доступа**. При совместном использовании памяти на каждом ее иерархическом уровне есть вероятность,
   что одна программа обратится к пространству памяти другой программы. Такая возможность может понадобиться, если она
   заложена в принцип работы данного приложения. С другой стороны, это угроза целостности программ и самой операционной
   системы. Операционная система должна следить за тем, каким образом различные пользователи могут осуществлять доступ к
   различным областям памяти.
5. **Долгосрочное хранение**. Многим приложениям требуются средства, с помощью которых можно было бы хранить информацию в
   течение длительного периода времени после выключения компьютера.

Обычно операционные системы выполняют эти требования с помощью средств виртуальной памяти и файловой системы. Файловая
система обеспечивает долгосрочное хранение информации, помещаемой в именованные объекты, которые называются файлами.
Файл - это удобная для программиста концепция, доступ к которой и защита которой осуществляются операционной системой.

**Виртуальная память** - это функциональная возможность, позволяющая программистам рассматривать память с логической точки
зрения, не заботясь о наличии физической памяти достаточного объема. Принципы работы с виртуальной памятью были
разработаны, чтобы задания нескольких пользователей, выполняясь параллельно, могли одновременно присутствовать в
основной памяти. При такой организации процессов нет задержки между их выполнением: как только один из процессов
заносится на вспомогательное запоминающее устройство, считывается следующий процесс. Из-за различий в количестве памяти,
требующемся для разных процессов, при переключении процессора с одного процесса на другой трудно компактно разместить их
в основной памяти. Поэтому были разработаны системы со страничной организацией памяти, при которой процесс разбивается
на блоки фиксированного размера, которые называются страницами. Обращение программы к слову памяти происходит по
**виртуальному адресу** (virtual address), который состоит из номера страницы и смещения относительно ее начала. Страницы
одного и того же процесса могут быть разбросаны по всей основной памяти. Системы со страничной организацией обеспечивают
динамическое отображение виртуального адреса, использующегося программой, и **реальным** (real address), или физическим,
адресом основной памяти.

Следующим логическим шагом развития в этом направлении (при наличии аппаратного обеспечения, позволяющего выполнять
динамическое отображение) было исключение требования, чтобы все страницы процесса одновременно находились в основной
памяти; достаточно, чтобы все они хранились на диске. Во время выполнения процесса только некоторые его страницы
находятся в основной памяти. Если программа обращается к странице, которая там отсутствует, аппаратное обеспечение,
управляющее памятью, обнаруживает это и организует загрузку недостающих страниц. Такая схема называется виртуальной
памятью; она проиллюстрирована на рис. 2.9.

Аппаратное обеспечение процессора вместе с операционной системой предоставляют пользователю "виртуальный процессор",
который имеет доступ к виртуальной памяти. Это хранилище может быть организовано в виде линейного адресного пространства
или в виде коллекции сегментов, представляющих собой смежные блоки переменной длины. При каждом из этих способов
организации можно обращаться к ячейкам виртуальной памяти, в которых содержатся программа и ее данные, с помощью команд
языка программирования. Чтобы изолировать процессы один от другого, каждому из них можно выделить свою область памяти,
не пересекающуюся с областью памяти другого процесса. Общее использование памяти можно организовать, частично перекрывая
части двух пространств виртуальной памяти. Файлы хранятся на долговременном запоминающем устройстве. Чтобы с ними могли
работать программы, файлы или их фрагменты могут копироваться в виртуальную память.

На рис. 2.10 поясняется концепция адресации в схеме виртуальной памяти. Хранилище состоит из основной памяти, открытой
для прямого доступа (осуществляемого с помощью машинных команд), а также более медленной вспомогательной памяти, доступ
к которой осуществляется косвенно, путем загрузки блоков в основную память. Между процессором и памятью находятся
аппаратные средства (модули управления памятью) для трансляции адресов.

![Концепция виртуальной памяти](/assets/q63-2.png)
Рис. 2.9. Концепция виртуальной памяти

Программы обращаются к ячейкам памяти с использованием виртуальных адресов, транслируемых в ходе обращения в реальные
адреса основной памяти. Если происходит обращение к виртуальному адресу, который не загружен в основную память, то один
из блоков реальной памяти меняется местами с нужным блоком, который находится во вспомогательной памяти. Во время этого
обмена процесс, который обратился к данному адресу, должен быть приостановлен. Задача разработки такого механизма
преобразования адресов, который не требовал бы больших дополнительных ресурсов, и такой стратегии размещения данных в
хранилище, которая сводила бы к минимуму перемещение данных между различными уровнями памяти, возлагается на
разработчика операционной системы.

![Адресация виртуальной памяти](/assets/q63-3.png)
Рис. 2.1О. Адресация виртуальной памяти

## Описание 2

В однозадачных системах основная память разделяется на две части: одна часть - для операционной системы (резидентный
монитор, ядро), а вторая - для выполняющейся в текущий момент времени программы. В многозадачных системах
"пользовательская" часть памяти должна быть распределена для размещения нескольких процессов. Эта задача распределения
выполняется операционной системой динамически и известна под названием **управление памятью** (memory management).

Эффективное управление памятью жизненно важно для многозадачных систем. Если в памяти располагается только небольшое
число процессов, то большую часть времен все эти процессы будут находиться в состоянии ожидания выполнения операций
ввода-вывода, и загрузка процессора будет низкой. Таким образом, желательно эффективное распределение памяти,
позволяющее разместить в ней как можно больше процессов.

Глава начинается с рассмотрения требований, которым должны удовлетворять разрабатываемые системы управления памятью.
Позже мы приступим к рассмотрению различных технологий управления памятью, начав с применения нескольких простых схем.

В табл. 7.1 приведены некоторые ключевые термины по данной теме.

ТАБЛИЦА 7.1. ОСНОВНЫЕ ТЕРМИНЫ, СВЯЗАННЫЕ С УПРАВЛЕНИЕМ ПАМЯТЬЮ

|                       |                                                                                                                                                                                                                                                                                                                                |
|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Кадр** (frame)      | Блок основной памяти фиксированной длины                                                                                                                                                                                                                                                                                       |
| **Страница** (page)   | Блок данных фиксированной длины, находящийся во вторичной памяти (такой, как диск). Страница данных может быть временно скопирована в кадр основной памяти                                                                                                                                                                     |
| **Сегмент** (segment) | Блок данных переменной длины, находящийся во вторичной памяти. В доступную область основной памяти может быть скопирован сегмент полностью (сегментация); возможно также разделение сегмента на страницы, которые копируются в основную память по отдельности (комбинированная сегментация, или страничная организация памяти) |

## ТРЕБОВАНИЯ К УПРАВЛЕНИЮ ПАМЯТЬЮ

При рассмотрении различных механизмов и стратегий, связанных с управлением памятью, полезно помнить требования, которым
они должны удовлетворять. Эти требования включают следующее.

- Перемещение
- Защита
- Совместное использование
- Логическая организация
- Физическая организация

### Перемещение

В многозадачной системе доступная основная память в общем случае разделяется среди множества процессов. Обычно
программист не знает заранее, какие программы будут резидентно находиться в основной памяти во время работы
разрабатываемой им программы. Кроме того, для максимизации загрузки процессора желательно иметь большой пул процессов,
готовых к выполнению, для чего требуется возможность загрузки и выгрузки активных процессов из основной памяти.
Требование, чтобы выгруженная из памяти программа была вновь загружена в то же самое место, где находилась и ранее, было
бы слишком сильным ограничением. Крайне желательно, чтобы программа могла быть **перемещена** (relocate) в другую
область памяти.

Таким образом, заранее неизвестно, где именно будет размещена программа, а кроме того, программа может быть перемещена
из одной области памяти в другую при свопинге. Эти обстоятельства обусловливают наличие определенных технических
требований к адресации, проиллюстрированных на рис. 7.1. На рисунке представлен образ процесса. Дпя простоты
предположим, что образ процесса занимает одну непрерывную область основной памяти. Очевидно, что операционной системе
необходимо знать местоположение управляющей информации процесса и стека выполнения, а также точки входа для начала
выполнения процесса. Поскольку управлением памятью занимается операционная система и она же размещает процесс в основной
памяти, соответствующие адреса она получает автоматически. Однако, помимо получения операционной системой указанной
информации, процесс должен иметь возможность обращаться к памяти в самой программе. Так, команды ветвления содержат
адреса, указывающие на команды, которые должны быть выполнены после них; команды обращения к данным - адреса байтов или
слов, с которыми они работают. Так или иначе, но процессор и программное обеспечение операционной системы должны быть
способны перевести ссылки в коде программы в реальные физические адреса, соответствующие текущему расположению программы
в основной памяти.

### Защита

Каждый процесс должен быть защищен от нежелательного воздействия других процессов, случайного или преднамеренного.
Следовательно, код других процессов не должен иметь возможности без разрешения обращаться к памяти данного процесса для
чтения или записи. Однако удовлетворение требованию перемещаемости усложняет задачу защиты.

![Требования к адресации процесса](/assets/q63-1.png)
Рис. 7.1. Требования к адресации процесса

Поскольку расположение программы в основной памяти непредсказуемо, проверка абсолютных адресов во время компиляции
невозможна. Кроме того, в большинстве языков программирования возможно динамическое вычисление адресов во время
выполнения (например, вычисление адреса элемента массива или указателя на поле структуры данных). Следовательно, во
время работы программы необходимо выполнять проверку всех обращений к памяти, генерируемых процессом, чтобы
удостовериться, что все они - только к памяти, выделенной данному процессу. К счастью, как вы увидите позже, механизмы
поддержки перемещений обеспечивают и поддержку защиты.

Обычно пользовательский процесс не может получить доступ ни к какой части операционной системы - ни к коду, ни к данным.
Код одного процесса не может выполнить команду ветвления, целевой код которой находится в другом процессе. Если не
приняты специальные меры, код одного процесса не может получить доступ к данным другого процесса. Процессор должен быть
способен прервать выполнение таких команд.

Заметим, что требования защиты памяти должны быть удовлетворены на уровне процессора (аппаратного обеспечения), а не на
уровне операционной системы (программного обеспечения), поскольку операционная система не в состоянии предвидеть все
обращения к памяти, которые будут выполнены программой. Даже если бы такое было возможно, сканирование каждой программы
в поиске предлагаемых нарушений защиты было бы слишком расточительным с точки зрения использования процессорного
времени. Следовательно, соответствующие возможности аппаратного обеспечения - единственное средство определения
допустимости обращения к памяти (данным или коду)во время работы программы.

### Совместное использование

Любой механизм защиты должен иметь достаточную гибкость для того, чтобы обеспечить возможность нескольким процессам
обращаться к одной и той же области основной памяти. Например, если несколько процессов выполняют один и тот же машинный
код, то будет выгодно позволить каждому процессу работать с одной и той же копией этого кода, а не создавать
собственную. Процессам, сотрудничающим в работе над некоторой задачей, может потребоваться совместный доступ к одним и
тем же структурам данных. Система управления памятью должна, таким образом, обеспечивать управляемый доступ к
разделяемым областям памяти, при этом никоим образом не ослабляя защиту памяти. Как мы увидим позже, механизмы поддержки
перемещений обеспечивают и поддержку совместного использования памяти.

### Логическая организация

Практически всегда основная память в компьютерной системе организована как линейное (одномерное) адресное пространство,
состоящее из последовательности байтов или слов. Аналогично организована и вторичная память на своем физическом уровне.
Хотя такая организация и отражает особенности используемого аппаратного обеспечения, она не соответствует способу,
которым обычно создаются программы. Большинство программ организованы в виде модулей, одни из которых неизменны (только
для чтения, только для выполнения), а другие содержат данные, которые могут быть изменены. Если операционная система и
аппаратное обеспечение компьютера могут эффективно работать с пользовательскими программами и данными, представленными
модулями, то это обеспечивает ряд преимуществ.

1. Модули могут быть созданы и скомпилированы независимо один от другого, при этом все ссылки из одного модуля во второй
   разрешаются системой во время работы программы
2. Разные модули могут получить разные степени защиты (только для чтения, только для выполнения) за счет весьма
   умеренных накладных расходов.
3. Возможно применение механизма, обеспечивающего совместное использование модулей разными процессами. Основное
   достоинство обеспечения совместного использования на уровне модулей заключается в том, что они соответствуют взгляду
   программиста на задачу и, следовательно, ему проще определить, требуется ли совместное использование того или иного
   модуля.

Инструментом, наилучшим образом удовлетворяющим данным требованиям, является сегментация, которая будет рассмотрена в
данной главе среди прочих методов управления памятью.

### Физическая организация

Как указывалось в разделе 1.5, память компьютера разделяется как минимум на два уровня: основная и вторичная. Основная
память обеспечивает быстрый доступ по относительно высокой цене; кроме того, она энергозависима, т.е. не обеспечивает
долговременное хранение. Вторичная память медленнее и дешевле основной и обычно энергонезависима. Следовательно,
вторичная память большой емкости может служить для долговременного хранения программ и данных, а основная память меньшей
емкости - для хранения программ и данных, использующихся в текущий момент.

В такой двухуровневой структуре основной заботой системы становится организация потоков информации между основной и
вторичной памятью. Ответственность за эти потоки может быть возложена и на отдельного программиста, но это непрактично и
нежелательно по следующим причинам.

1. Основной памяти может быть недостаточно для программы и ее данных. В этом случае программист вынужден прибегнуть к
   практике, известной как структуры с перекрытием - **оверлеи** (overlay), когда программа и данные организованы таким
   образом, что различные модули могут быть назначены одной и той же области памяти; основная программа при этом
   ответственна за перезагрузку модулей при необходимости. Даже при помощи соответствующего инструментария компиляции
   оверлеев разработка таких программ приводит к дополнительным затратам времени программиста.
2. Во многозадачной среде программист при разработке программы не знает, какой объем памяти будет доступен программе и
   где эта память будет располагаться.

Таким образом, очевидно, что задача перемещения информации между двумя уровнями памяти должна возлагаться на
операционную систему. Эта задача является сущностью управления памятью.
