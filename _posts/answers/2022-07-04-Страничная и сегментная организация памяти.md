---
layout: post
title: "Страничная и сегментная организация памяти"
categories: sppo-questions pors-questions
---

## Страничная организация памяти

Как разделы с разными фиксированными размерами, так и разделы переменного размера недостаточно эффективно
используют память. Результатом работы первых становится внутренняя фрагментация, результатом работы
последних - внешняя. Предположим, однако, что основная память разделена на одинаковые блоки относительно
небольшого фиксированного размера. Тогда блоки процесса, известные как **страницы (pages)**, могут быть связаны
со свободными блоками памяти, известными как **кадры (frames)** или **фреймы**. Каждый кадр может содержать одну
страницу данных. При такой организации памяти, о которой вы узнаете из этого раздела, внешняя фрагментация
отсутствует вовсе, а потери из-за внутренней фрагментации ограничены частью последней страницы процесса.

![Распределение страниц по свободным кадрам](/assets/q58-1.png)

На рис.1 показано использование страниц и кадров. В любой момент времени некоторые из кадров памяти используются,
а некоторые свободны. Операционная система поддерживает список свободных кадров. Процесс А, хранящийся на диске,
состоит из четырех страниц. Когда приходит время загрузить этот процесс в память, операционная система находит
четыре свободных кадра и загружает страницы процесса А в эти кадры. Затем загружаются процесс В, состоящий из
трех страниц, и процесс С, состоящий из четырех страниц. После этого процесс В приостанавливается и выгружается
из основной памяти. Позже наступает момент, когда все процессы в памяти оказываются заблокированными, и операционная
система загружает в память новый процесс D, состоящий из пяти страниц.

Теперь предположим, что, как в только что рассмотренном выше примере, не имеется одной непрерывной области кадров,
достаточной для размещения процесса целиком. Помешает ли это операционной системе загрузить процесс D? Нет, поскольку
в этой ситуации можно воспользоваться концепцией логических адресов. Однако одного регистра базового адреса в этой
ситуации недостаточно, и для каждого процесса операционная система должна поддерживать **таблицу страниц**. Таблица страниц
указывает расположение кадров каждой страницы процесса. Внутри программы логический адрес состоит из номера страницы и
смещения внутри нее. Вспомним, что в случае простого распределения логический адрес представляет собой расположение слова
относительно начала программы, которое процессор транслирует в физический адрес. При страничной организации преобразование
логических адресов в физические также остается задачей аппаратного уровня, решаемой процессором.

Теперь процессор должен иметь информацию о том, где находится таблица страниц текущего процесса. Представленный логический
адрес (номер страницы и смещение) процессор превращает с использованием таблицы страниц в физический адрес (номер кадра, смещение).

![Структуры данных, соответствующие примеру на рис. 7.9,е](/assets/q58-3.png)

На рис.2 показаны различные таблицы страниц, после того как процесс 0 оказывается загруженным в страницы 4, 5, 6, 11 и 12.
Таблица страниц содержит по одной записи для каждой страницы процесса, так что таблицу легко проиндексировать номером
страницы, начиная с 0. Каждая запись содержит номер фрейма в основной памяти (если таковой имеется), в котором хранится
соответствующая страница. Кроме того, операционная система поддерживает единый список свободных (т.e. не занятых никаким
процессом и доступных для размещения в них страниц) кадров.

Таким образом, описанная здесь простая страничная организация подобна фиксированному распределению. Отличия заключаются
в достаточно малом размере разделов, которые к тому же могут не быть смежными.

Использование страниц с размером, равным степени двойки, приводит к таким следствиям. Во-первых, схема логической адресации
прозрачна для программиста, ассемблера и компоновщика. Каждый логический адрес (номер страницы и смещение) программы
идентичен относительному адресу. Во-вторых, при этом относительно просто реализуется аппаратная функция преобразования
адресов во время работы. Рассмотрим адрес из $n+m$ бит, где крайние слева $n$ бит представляют собой номер страницы,
а крайние справа $m$ бит - смещение. В нашем примере $n = 6$ и $m = 10$. Для преобразования адреса необходимо выполнить
следующие шаги.

1. Выделить номер страницы, который представлен $n$ левыми битами логического адреса.
2. Используя номер страницы в качестве индекса в таблице страниц процесса, найти номер кадра $k$.
3. Начальный физический адрес кадра - $k*2^m$, и интересующий нас физический адрес представляет собой это число плюс
   смещение. Такой адрес не надо вычислять - он получается в результате простого добавления номера кадра к смещению.

![Примеры трансляции логических адресов в физические](/assets/q58-2.png)

В нашем примере имеется логический адрес 0000010111011110, представляющий страницу номер 1 и смещение 478. Предположим,
что эта страница размещена в кадре основной памяти номер 6 (бинарное представление - 000110). В таком случае физический
адрес представляет собой кадр 6, смещение 4 78, т.е. 0001100111011110 (рис. 3). Итак, в случае простой страничной организации
основная память разделяется на множество небольших кадров одинакового размера. Каждый процесс разделяется на страницы того
же размера, что и кадры; малые процессы требуют меньшего количества кадров, большие - большего. При загрузке процесса в
память все его страницы загружаются в свободные кадры, и информация о размещении страниц заносится в соответствующую таблицу.
Такой подход позволяет избежать множества присущих распределению памяти проблем.

## Сегментация

Альтернативным способом распределения пользовательской программы является сегментация. В этом случае программа
и связанные с ней данные разделяются на ряд **сегментов**. Хотя и существует максимальный размер сегмента, на сегменты
не накладывается условие равенства размеров. Как и при страничной организации, логический адрес состоит из двух
частей, в данном случае - номера сегмента и смещения.

Использование сегментов разного размера делает этот способ похожим на динамическое распределение памяти. Если не
используются оверлеи и виртуальная память, то для выполнения программы все ее сегменты должны быть загружены в
память; однако в отличие от динамического распределения в этом случае сегменты могут занимать несколько разделов,
которые к тому же могут не быть смежными.

При сегментации устраняется внутренняя фрагментация, однако, как и при динамическом распределении, наблюдается
внешняя фрагментация. Тем не менее ее степень снижается, в силу того что процесс разбивается на ряд небольших частей.

В то время как страничная организация невидима для программиста, сегментация, как правило, видима и обычно
используется при размещении кода и данных в разных сегментах. При использовании принципов модульного
программирования как код, так и данные могут быть дополнительно разбиты на сегменты. Главным недостатком при
работе с сегментами является необходимость заботиться о том, чтобы размер сегмента не превысил максимальный.

Еще одно следствие того, что сегменты имеют разные размеры, состоит в отсутствии простой связи между логическими
и физическими адресами. Аналогично страничной организации схема простой сегментации использует таблицу сегментов
для каждого процесса и список свободных блоков основной памяти. Каждая запись таблицы сегментов должна содержать
стартовый адрес сегмента в основной памяти и его длину, чтобы обезопасить систему от использования некорректных
адресов. При работе процесса адрес его таблицы сегментов заносится в специальный регистр, используемый аппаратным
обеспечением управления памятью. Рассмотрим адрес из $n+m$ бит, где крайние слева $n$ бит являются номером сегмента,
а правые $m$ бит - смещением. В примере, показанном на рис. 1,в  $n = 4$ и $m = 12$. Таким образом, максимальный
размер сегмента составляет $2^{12} = 4096$ байт. Для трансляции адреса необходимо выполнить следующие действия.

1. Выделить из логического адреса $n$ крайних слева битов, получив таким образом номер сегмента.
2. Используя номер сегмента в качестве индекса в таблице сегментов процесса, найти физический адрес начала сегмента.
3. Сравнить смещение, представляющее собой крайние справа $m$ бит, с длиной сегмента. Если смещение больше длины,
   адрес некорректен.
4. Требуемый физический адрес представляет собой сумму физического адреса начала сегмента и смещения.

В нашем примере имеется логический адрес 0001001011110000, представляющий собой сегмент номер 1, смещение 752.
Предположим, что этот сегмент располагается в основной памяти начиная с физического адреса 0010000000100000.
Тогда интересующий нас физический адрес равен $0010000000100000+001011110000 = 0010001100010000$ (см. рис. 3,6).

Итак, в случае простой сегментации процесс разделяется на ряд сегментов, размер которых может быть разным. При
загрузке процесса все его сегменты размещаются в свободных областях памяти и соответствующая информация вносится
в таблицу сегментов.