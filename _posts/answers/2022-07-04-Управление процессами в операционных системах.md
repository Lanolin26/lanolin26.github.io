---
layout: post
title: "Управление процессами в операционных системах"
categories: sppo-questions pors-questions
---

### Режимы выполнения

Перед тем как продолжить обсуждение способов, с помощью которых операционная система управляет процессами,
нужно разобраться, в чем состоит различие между режимами работы процессора при выполнении кода операционной
системы и при выполнении кодов пользовательских программ. Большинство процессоров поддерживают по крайней
мере два режима работы. Определенные команды выполняются только в более привилегированном режиме. К ним
относятся операции считывания или внесения изменений в управляющие регистры (например, операции со словом
состояния программы), команды ввода-вывода, а также команды, связанные с управлением памятью. Кроме того,
доступ к некоторым областям памяти может быть получен только в более привилегированном режиме.

Режим с меньшими привилегиями часто называют **пользовательским режимом** (user mode), потому что обычно в этом
режиме выполняются пользовательские программы. Режим с более высокими привилегиями называется **системным режимом**
(system mode), **режимом управления** (control mode) или **режимом ядра** (kernel mode). В последнем названии
упоминается ядро, т.е. часть операционной системы, которая выполняет важнейшие ее функции. Перечислены те из
функций операционной системы, которые обычно возлагаются на ее ядро:

- **Управление процессами**
    - Создание и завершение процессов
    - Планирование и диспетчеризация процессов
    - Переключение процессов
    - Синхронизация и поддержка обмена информацией между процессами
    - Организация управляющих блоков процессов
- **Управление памятью**
    - Выделение адресного пространства процессам
    - Свопинг
    - Управление страницами и сегментами
- **Управление вводом-выводом**
    - Управление буферами
    - Выделение процессам каналов и устройств ввода-вывода
- **Функции поддержки**
    - Обработка прерываний
    - Учет использования ресурсов
    - Текущий контроль системы
- **Функции поддержки**
    - Обработка прерываний
    - Учет использования ресурсов
    - Текущий контроль системы

Нетрудно понять, зачем нужны два вышеуказанных режима. Необходимо защитить операционную систему и ее основные
таблицы, такие как управляющие блоки процессов, от воздействия пользовательских программ. Программы, работающие
в режиме ядра, обладают полным контролем над процессором и всеми его командами и регистрами, а также имеют доступ
ко всем ячейкам памяти. Такой уровень привилегий пользовательским программам не нужен поэтому, исходя из
соображений безопасности, лучше сделать его недоступным для пользовательских программ.

В связи с этим возникают два вопроса: каким образом процессор может определить, в каком режиме должна выполняться
данная программа, и как происходит переключение из одного режима в другой? Что касается ответа на первый вопрос,
то в слове состояния программы имеется бит, в котором указывается режим выполнения. При некоторых событиях
происходит изменение этого бита. Например, если пользователь вызывает службу операционной системы, устанавливается
режим ядра (обычно это происходит в результате выполнения команд изменения режима), а по окончании работы системной
службы режим вновь переключается на пользовательский. В качестве примера рассмотрим процессор Intel Itanium, который
реализует 64-разрядную архитектуру IA-64. Этот процессор имеет регистр состояния процессора (processor status
register - psr), который включает двухбитное поле текущего уровня привилегий (current privilege level - cpl). Уровень
0 является наиболее привилегированным уровнем, в то время как уровень 3 - наименее привилегированным. Большинство
операционных систем, таких как Linux, используют уровень 0 для ядра и один из прочих уровней для пользовательского
режима. Когда происходит прерывание, процессор сбрасывает большую часть битов в регистре состояния процессора,
включая поле текущего уровня привилегий. Это автоматически устанавливает clp равным 0. В конце процедуры обработки
прерываний выполняется команда возврата из прерывания irt (interrupt return). Она заставляет процессор восстановить
регистр состояния процессора прерванной программы, что восстанавливает ее уровень привилегий. Подобная
последовательность
действий выполняется, когда приложение выполняет системный вызов. В Itanium приложение осуществляет системный вызов,
помещая идентификатор системного вызова и его аргументы в предопределенные области, а затем выполняется специальная
команда, которая имеет тот же эффект, что и выполнение прерывания на пользовательском уровне, и передает управление
ядру.

### Создание процессов

Этапы создания процессов.

К созданию процесса могут привести четыре события, перечисленные в табл. 3.1.

ТАБЛИЦА 3.1. ПРИЧИНЫ СОЗДАНИЯ ПРОЦЕССОВ

|                                                                                   |                                                                                                                                                                                                                                                                  |
|-----------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Новое пакетное задание                                                            | В операционную систему для обработки поступает управляющий поток пакетных заданий (обычно с ленты или с диска). Готовясь принять на обработку новое задание, операционная система считывает очередную последовательность команд управления заданиями             |
| Вход в систему в интерактивном режиме                                             | В систему с терминала входит новый пользователь                                                                                                                                                                                                                  |
| Создание операционной системой процесса, необходимого для работы каких-либо служб | Операционная система может создать процесс для выполнения некоторой функции, которая требуется для программы пользователя. При этом пользователь не должен ждать, пока закончится ее выполнение (как в примере, в котором создавался процесс управления печатью) |
| Порождение одного процесса другим                                                 | С целью структуризации программы или использования возможностей параллельных вычислений программа может создавать другие процессы                                                                                                                                |

Если операционная система по какой-либо (см. табл. 3.1) причине приняла решение создать процесс, она может сделать
это следующим образом.

1. **Присвоить новому процессу уникальный идентификатор**. На этом этапе в первичную таблицу процессов вносится новая
   запись.
2. **Выделить пространство для процесса**. Сюда включаются все элементы образа процесса. Операционная система должна
   знать, сколько места нужно для пользовательского адресного пространства (для программ и данных) и для
   пользовательского стека. Эти значения могут назначаться по умолчанию исходя из типа процесса или могут быть
   установлены на основе запроса пользователя при создании задания. Если процесс порождается другим процессом,
   родительский процесс может передать операционной системе необходимые величины, поместив их в запрос на создание
   процесса. Если вновь создающийся процесс будет использовать какую-то часть адресного пространства совместно с
   другими процессами, необходимо установить соответствующие связи. И наконец, нужно выделить место для управляющего
   блоком процесса.
3. **Инициализировать управляющий блок процесса**. Информация о процессе содержит его идентификатор, а также некоторые
   другие идентификаторы, например идентификатор родительского процесса. Информация о состоянии процессора обычно
   инициализируется нулевыми значениями, за исключением счетчика команд (который содержит точку входа в программу)
   и указателей системного стека (задающие границы стека процесса). Инициализация управляющей информации происходит
   на основе значений, установленных по умолчанию, с учетом атрибутов из запроса на создание процесса. Например,
   состояние процесса обычно инициализируется значением "готов" или "готов и приостановлен". Что касается приоритета,
   то по умолчанию он может быть установлен минимальным, если не поступил явный запрос на установку более высокого
   приоритета. Поначалу процесс может не владеть никакими ресурсами (типа устройств ввода-вывода или файлов), если
   не сделан явный запрос или если эти ресурсы не были переданы по наследству от родительского процесса.
4. **Установить необходимые связи**. Если операционная система, например, поддерживает очередь планируемых заданий в
   виде списка со связями, то новый процесс необходимо поместить в список готовых или готовых/приостановленных
   процессов.
5. **Создать или расширить другие структуры данных**. Операционная система может, например, поддерживать для
   каждого процесса файл с учетом используемых ресурсов, который позже будет использован для учета или оценки
   производительности системы.

### Переключение процессов

Казалось бы, функция переключения процессов проста и понятна. В какой-то момент времени выполняющийся процесс
прерывается и операционная система переводит в состояние выполнения другой процесс, передавая ему управление.
Однако здесь возникают некоторые вопросы, касающиеся архитектуры операционной системы. Во-первых, какие события
должны приводить к переключению процессов? Во-вторых, как установить различие между переключением режимов работы
и переключением процессов? И наконец, что нужно делать операционной системе с различными структурами данных,
находящимися под ее управлением, чтобы переключить процесс?

#### Когда нужно переключать процессы

Переключение процесса может произойти в любой момент, когда управление от выполняющегося процесса переходит
к операционной системе. В табл. 3.8 перечислены возможные причины, по которым управление может перейти к
операционной системе.

ТАБЛИЦА 3.8. МЕХАНИЗМЫ ПРЕРЫВАНИЯ ВЫПОЛНЕНИЯ ПРОЦЕССА

| Механизм          | Причина                                           | Что используется                             |
|-------------------|---------------------------------------------------|----------------------------------------------|
| Прерывание        | Внешняя по отношению к выполнению текущей команды | Отклик на внешнее асинхронное событие        |
| Ловушка           | Связана с выполнением текущей команды             | Обработку ошибки или исключительной ситуации |
| Вызов супервизора | Явный запрос                                      | Вызов функции операционной системы           |

Сначала рассмотрим системные прерывания. Фактически имеются системные прерывания двух видов. Первый вид -
обычные прерывания, а второй - ловушки (trap). Прерывания первого вида происходят из-за событий определенного
типа, не связанных с выполняющимся процессом и являющихся внешними по отношению к нему (таким событием может
быть, например, завершение операции ввода-вывода). Ловушки связаны с ошибкой или исключительной ситуацией,
возникшей в результате выполнения текущего процесса. В качестве примера можно привести попытку получения
незаконного доступа к файлу. При обычном **прерывании** управление сначала передается обработчику прерываний,
который осуществляет некоторые подготовительные действия, а затем - функции операционной системы, отвечающей
за прерывания данного вида. Приведем конкретные примеры прерываний.

- **Прерывание таймера**. Операционная система определяет, что текущий процесс выполняется в течение максимально
  разрешенного промежутка времени, именуемого **квантом времени** (time slice). Квант времени представляет собой
  максимальное количество времени, которое процесс может выполняться без прерывания. Если это так, то данный
  процесс нужно переключить в состояние готовности и передать управление другому процессу.
- **Прерывание ввода-вывода**. Операционная система определяет, что именно произошло, и если это то событие, которого
  ожидают один или несколько процессов, операционная система переводит все соответствующие блокированные процессы
  в состояние готовности (соответственно, блокированные/приостановленные процессы она переводит в состояние
  готовых/приостановленных процессов). Затем операционная система должна принять решение: возобновить выполнение
  текущего процесса или передать управление готовому к выполнению процессу с более высоким приоритетом.
- **Ошибка отсутствия блока в памяти**. Допустим, что процессор должен обратиться к слову виртуальной памяти,
  которое в настоящий момент отсутствует в основной памяти. При этом операционная система должна загрузить в
  основную память блок (страницу или сегмент), в котором содержится адресованное слово. Сразу же после запроса
  на загрузку блока операционная система может передать управление другому процессу, а процесс, для продолжения
  выполнения которого нужно загрузить блок в основную память, переходит в блокированное состояние. После загрузки
  нужного блока этот процесс переходит в состояние готовности.

В случае **ловушки** (trap) операционная система определяет, является ли ошибка или исключительная ситуация
фатальной. Если это так, то выполняющийся в данный момент процесс переходит в состояние завершающегося, а управление
переходит к другому процессу. В противном случае действия операционной системы будут зависеть от характера происшедшей
ошибки, а также от конструкции самой операционной системы. Может быть предпринята попытка выполнить восстановительные
процедуры или просто поставить пользователя в известность о происшедшей ошибке. Операционная система при этом может
как выполнить переключение процессов, так и продолжить выполнение текущего процесса.

Наконец, операционная система может быть активирована в результате **вызова супервизора** (supervisor call), который
исходит от выполняемой программы. Например, пусть в ходе работы пользовательского процесса нужно выполнить команду,
для которой требуется операция ввода-вывода, например открытие файла. Такой вызов приведет к тому, что управление
перейдет к процедуре, являющейся частью кода операционной системы. Вообще говоря, использование таких системных
вызовов приводит к переходу процесса в блокированное состояние.

#### Переключение режимов

В главе 1, "Обзор компьютерной системы", нами рассматривалась целесообразность включения цикла прерывания в цикл
команды. Напомним, что в ходе цикла прерывания процессор проверяет, не поступили ли какие-нибудь прерывания, на
наличие которых указывает сигнал прерывания. Если никаких прерываний нет, процессор переходит к циклу выборки,
извлекая из памяти очередную команду, входящую в текущую программу. Если же имеются необработанные прерывания,
то процессор выполняет следующие действия.

1. Устанавливает в счетчике команд начальный адрес программы - обработчика прерываний.
2. Переключается из пользовательского режима в режим ядра, чтобы можно было выполнять привилегированные команды,
   содержащиеся в коде обработки прерывания.

После этого процессор переходит к циклу выборки и выбирает первую команду из программы обработки прерываний,
обслуживающей данное прерывание. Обычно в этот момент контекст прерванного процесса сохраняется в управляющем блоке
процесса прерванной программы.

Может возникнуть вопрос: что входит в состав сохраняемого контекста? Этот контекст должен содержать информацию,
которая может быть изменена в процессе работы обработчика прерываний и которая необходима для возобновления
выполнения прерванной программы. Таким образом, должна быть сохранена часть управляющего блоком процесса с
информацией о состоянии процессора. В нее входит содержимое счетчика команд и других регистров процессора,
а также информация о стеках.

Нужно ли сделать что-нибудь еще? Это зависит от дальнейших событий. Обычно обработчик прерываний является
короткой программой, которая выполняет несколько базовых действий, связанных с прерыванием. Например, эта
программа сбрасывает флаг состояния, сигнализирующий о наличии прерываний. Она может послать подтверждение
о получении прерывания тому элементу аппаратного обеспечения, который сгенерировал это прерывание (например,
контроллеру ввода-вывода). Кроме того, эта программа может выполнить некоторые служебные действия, связанные
с событием, сгенерировавшим прерывание. Например, если прерывание связано с вводом-выводом, обработчик
прерываний проверит, не произошло ли ошибки при его выполнении. Если произошла ошибка, обработчик может послать
сигнал процессу, первоначально выдавшему запрос на операцию ввода-вывода. Если прерывание сгенерировано таймером,
программа обработки прерываний передаст управление диспетчеру. Диспетчер выполнит переключение процессора на
обработку другого процесса, если промежуток времени, отведенный на выполнение текущего процесса, уже истек.

А как быть с остальной информацией, содержащейся в управляющем блоке процесса? Если вслед за данным прерыванием
последует переключение на другой процесс, то нужно выполнить соответствующие действия по переключению. Однако в
большинстве операционных систем прерывание необязательно влечет за собой переключение процессов. По окончании работы
обработчика прерываний возможно возобновление выполнения того процесса, который выполнялся и до прерывания. В некоторых
случаях во время прерывания достаточно сохранить только информацию о состоянии процессора. После того как управление
вновь возвратится к выполнявшейся перед прерыванием программе, нужно будет лишь восстановить эту информацию. Обычно
функция сохранения и восстановления состояния процессора возлагается на аппаратное обеспечение.

#### Изменение состояния процесса

Понятно, что переключение режима работы процессора и переключение процессов - это не одно и то же.

> В литературе по операционным системам часто встречается термин переключение контекста (context switch). К
> сожалению, хотя в большинстве изданий этот термин используется для обозначения действий, которые в нашей книге
> называются переключением процессов, в других источниках он используется для обозначения переключения режима работы
> процессора или даже переключения потоков (о котором пойдет речь в следующей главе). Поэтому термин переключение
> контекста в данной книге во избежание его неоднозначного понимания не используется.

Переключение режима может происходить без изменения состояния процесса, выполняющегося в данное время. В этом случае
сохранение контекста и его последующее восстановление не приведет к большим накладным расходам. Однако если
выполняющийся в текущий момент времени процесс нужно перевести в другое состояние (состояние готовности, блокированное и
т.д.), то операционная система должна произвести в своей среде определенные изменения. В случае переключения процессов
должны быть выполнены следующие действия.

1. Сохранение контекста процессора, включая содержимое счетчика команд и других регистров.
2. Обновление управляющего блока выполняющегося в данное время процесса. Сюда входит изменение состояния процесса на
   одно из следующих: готовый, блокированный, готовый/приостановленный или завершающийся. Кроме того, должно быть
   обновлено содержимое других полей с указанием причины переключения процесса из состояния выполнения, а также с
   сохранением информации по учету используемых ресурсов.
3. Помещение управляющего блока данного процесса в соответствующую очередь (очередь готовых к выполнению процессов;
   процессов, блокированных событием i; очередь готовых/приостановленных процессов).
4. Выбор следующего процесса для выполнения; эта тема исследуется в части IV книги.
5. Обновление управляющего блока выбранного процесса. Для этого процесса нужно установить состояние выполнения.
6. Обновление структур данных по управлению памятью. Понадобится ли эта информация, зависит от того, каким образом
   выполняется преобразование адресов (подробно эта тема рассматривается в части III книги).
7. Восстановление состояния процессора, в котором он находился, когда выбранный процесс был последний раз переключен из
   состояния выполнения. Это происходит путем загрузки содержимого программного счетчика и других регистров процессора.

Таким образом, переключение процесса, включающее переключение его состояния, требует значительно больших усилий по
сравнению с переключением режима работы процессора.
