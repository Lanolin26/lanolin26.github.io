---
layout: post
title: "Алгоритмы замещения страниц виртуальной памяти"
categories: sppo-questions pors-questions
---

[comment]: <> (https://vk.com/doc44301783_566716983?hash=IUuU3Ud0zhZInQ3YyEMVr8u2IxQjbdxeRhzKdFfQ578&dl=zfO6nrlL0lYELe13vXto4dPawq7uLC8GMVZH2nZg7gg)

В многозадачной системе с использованием динамического распределения наступает момент, когда все
процессы в основной памяти находятся в заблокированном состоянии, а памяти для дополнительного
процесса недостаточно даже после уплотнения. Чтобы избежать потерь процессорного времени на
ожидание деблокирования активного процесса операционная система может выгрузить один из процессов
из основной памяти и, таким образом, освободить место для нового процесса или процесса в состоянии
готовности. Задача операционной системы определить какой именно процесс должен быть выгружен из памяти.

Основные алгоритмы:

- Оптимальный алгоритм
- Алгоритм дольше всех неиспользовавшегося элемента
- Алгоритм первый вошел первый вышел
- Часовой алгоритм

![Поведение четырех алгоритмов замещения страниц](/assets/q3-1.png)

**Оптимальная стратегия** состоит в выборе для замещения той страницы, обращение к которой
будет через наибольший промежуток времени по сравнению со всеми остальными страницами.
Можно показать, что этот алгоритм приводит к минимальному количеству прерываний из-за
отсутствия страницы. Понятно, что реализовать такой алгоритм невозможно, поскольку для
этого системе требуется знать все будущие события. Однако этот алгоритм является стандартом,
с которым сравниваются реальные алгоритмы.

Предполагается, что для данного процесса используется фиксированное распределение кадров
(фиксированный размер резидентного множества, состоящего из трех кадров). Выполнение
процесса приводит к обращениям к пяти различным страницам. В процессе работы обращения
к страницам выполняются в следующем порядке:

    2 3 2 5 2 4 5 3 2 5 2

Это означает, что сначала выполняется обращение к странице 2, затем - к странице 3 и т.д.
Оптимальная стратегия приводит после заполнения всего множества кадров к трём прерываниям
обращения к странице (обозначенным на рисунке буквами "F").

**Стратегия дольше всех неиспользовавшегося элемента** замещает в памяти ту страницу, обращений
к которой не было дольше, чем к другим. Согласно принципу локальности можно ожидать, что
эта страница не будет использоваться и в ближайшем будущем. Эта стратегия и в самом деле
недалека от оптимальной. Основная проблема заключается в сложности ее реализации. Один из
вариантов реализации предполагает отмечать время последнего обращения к странице; это должно
делаться при каждом обращении к памяти, независимо от того, к чему выполняется обращение -
к коду или к данным. Даже в случае аппаратной поддержки этой схемы накладные расходы слишком
велики. Еще один вариант предполагает поддержание стека обращений к страницам, что тоже
обходится недешево для производительности системы.

На рис. 1 приведен пример выполнения алгоритма дольше всех неиспользовавшегося элемента с
тем же потоком данных, что и для оптимального алгоритма. В этом примере возникают четыре
прерывания обращения к странице.

Стратегия **первым вошел - первым вышел** рассматривает кадры страниц процесса как циклический
буфер с циклическим же удалением страниц из него. Все, что требуется для реализации этой
стратегии, - это указатель, циклически проходящий по кадрам страниц процесса. Таким образом,
это одна из простейших в реализации стратегий замещения. Логика ее работы заключается в том,
что замещается страница, находящаяся в основной памяти дольше других. Однако далеко не всегда
эта страница редко используется; очень часто некоторая область данных или кода интенсивно
используется программой, и страницы из этой области при использовании описанной стратегии
будут загружаться и выгружаться вновь и вновь.

На рис. 1 описанная стратегия приводит к шести прерываниям отсутствия страницы. Заметим, что
предыдущая стратегия распознает, что чаще других используются страницы 2 и 5, в то время как
стратегия "первым вошел - первым вышел" на это не способна.

Хотя стратегия дольше всех неиспользовавшегося элемента и близка к оптимальной, она трудна в
реализации и приводит к значительным накладным расходам. Стратегия "первым вошел - первым вышел"
реализуется очень просто, но относительно редко приводит к хорошим результатам. В течение долгого
времени разработчики операционных систем испытывали различные алгоритмы, пытаясь достичь увеличения
производительности стратегии дольше всех неиспользовавшегося элемента при значительном снижении
накладных расходов. Многие из этих алгоритмов представляют собой варианты схемы, известной как
**часовая стратегия** (clock policy).

В простейшей схеме часовой стратегии с каждым кадром связывается один дополнительный бит,
известный как бит использования. Когда страница впервые загружается в кадр, бит использования
устанавливается равным 1. При последующих обращениях к странице, вызвавших прерывание из-за
отсутствия страницы, этот бит также устанавливается равным 1. При работе алгоритма замещения
множество кадров, являющихся кандидатами на замещение (текущий процесс, локальная область
видимости, вся основная память или глобальная область видимости) рассматривается как циклический
буфер, с которым связан указатель. При замещении страницы указатель перемещается к следующему
кадру в буфере. Когда наступает время замещения страницы, операционная система сканирует буфер
для поиска кадра, бит использования которого равен О. Всякий раз, когда в процессе поиска
встречается кадр с битом использования, равным 1, он сбрасывается в О. Первый же встреченный
кадр с нулевым битом использования выбирается для замещения. Если все кадры имеют бит
использования, равный 1, указатель совершает полный круг и возвращается к начальному положению,
заменяя страницу в этом кадре. Как видим, эта стратегия схожа со стратегией "первым вошел -
первым вышел", но отличается тем, что кадры, имеющие установленный бит использования,
пропускаются алгоритмом. Буфер кадров страниц представлен в виде круга, откуда и произошло
название стратегии. Ряд операционных систем используют различные варианты часовой стратегии
(например, Multics).

![Пример работы часового алгоритма](/assets/q3-2.png)

На рис. 2 приведен простейший пример использования часовой стратегии. Для замещения доступны $n$
кадров основной памяти, представленные в виде циклического буфера. Непосредственно перед тем, как
заместить страницу в буфере загружаемой из вторичной памяти страницей 727, указатель буфера указывает
на кадр 2, содержащий страницу 45.

Теперь приступим к выполнению часового алгоритма. Поскольку бит использования страницы 45 в кадре 2
равен 1, эта страница не замещается; вместо этого ее бит использования сбрасывается, а указатель
перемещается к следующему кадру. Не замещается также страница 191 из кадра 3; в соответствии с
алгоритмом сбрасывается ее бит использования. В следующем кадре (номер 4) бит использования
страницы равен О. Таким образом, страница 556 замещается загружаемой в основную память страницей
727, бит использования которой устанавливается равным 1. Далее указатель буфера переходит к кадру 5,
и на этом выполнение алгоритма завершается.

Поведение часового алгоритма проиллюстрировано на рис. 1. Звездочка означает, что бит использования
соответствующей страницы равен 1, а стрелочка указывает текущее положение указателя. Заметим, что
данный алгоритм пытается защитить страницы 2 и 5 от замещения.

Повысить эффективность часового алгоритма можно путем увеличения количества используемых при его
работе битов (С другой стороны, уменьшение количества битов до нуля даст нам алгоритм "первым
вошел - первым вышел"). Во всех поддерживающих страничную организацию процессорах с каждой
страницей в основной памяти (а следовательно, с каждым кадром) связан бит модификации. Этот
бит используется для указания того, что данная страница не может быть замещена до тех пор, пока
ее содержимое не будет записано обратно во вторичную память. Этот бит может использоваться
часовым алгоритмом следующим образом. Принимая во внимание биты использования и модификации,
все кадры можно разделить на четыре категории ($u$ - бит использования, $m$ - бит модификации):

1. использован давно, не модифицирован ($u = О$, $m = О$);
2. использован недавно, не модифицирован ($u = 1$, $m = О$);
3. использован давно, модифицирован ($u = О$, $m = 1$);
4. использован недавно, модифицирован ($u= 1$, $m = 1$).

Используя эту классификацию, изменим часовой алгоритм, который теперь описывается следующим образом.

1. Сканируем буфер кадров, начиная с текущего положения. В процессе сканирования бит использования
   не изменяется. Первая же страница с состоянием ($u = О$, $m = О$) замещается.
2. Если выполнение первого шага алгоритма не увенчалось успехом, ищем страницу с параметрами
   ($u = О$, $m = 1$). Если таковая найдена, она замещается. В процессе выполнения данного шага
   у всех просмотренных страниц сбрасывается бит использования.
3. Если выполнение предыдущего шага не дало результата, указатель возвращается в исходное положение,
   но у всех страниц значение бита использования сброшено в О. Повторим шаг 1 и при необходимости -
   шаг 2. Очевидно, на этот раз требуемая страница будет найдена.

Итак, часовой алгоритм циклически проходит по всем страницам буфера в поисках страницы, которая не
была модифицирована со времени загрузки и давно не использовалась. Такая страница - хороший кандидат
на замещение, особенно с учетом того, что ее не надо записывать на диск. Если при первом проходе
кандидатов на замещение не нашлось, алгоритм снова проверяет буфер, теперь уже в поисках
модифицированной, давно не использовавшейся страницы. Хотя такая страница и должна быть записана
перед замещением, в соответствии с принципом локальности она вряд ли понадобится в ближайшем будущем.
Если и этот проход окажется неудачным, все страницы помечаются как давно не использованные, и
выполняется третий проход.

Такой алгоритм использован в схеме виртуальной памяти Macintosh. Преимущество этого алгоритма состоит,
в отличие от простого часового алгоритма, в замене не изменявшихся страниц по сравнению с заменой
модифицированных страниц, что дает непосредственную экономию времени.
